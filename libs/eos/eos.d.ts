// Generated by dts-bundle v0.7.3
declare namespace EOS {
export class EOS {
    readonly connector: EOSConnector;
    static instance: EOS;
    static switchNetwork(network: string): void;
    constructor(connector: EOSConnector);
    readonly network: Network;
    hasPlugin(): boolean | undefined;
    loggedIn(): boolean;
    connect(): Promise<any>;
    readonly account: Account;
    getTableRows(table: Table<any>, limit: number, lower: string): Promise<any>;
    getAccountInfo(): Promise<AccountInfo>;
    call(contract: string, actionName: string, data: any): Promise<TransactionResult>;
    transfer(to: string, asset: Asset, memo?: string): Promise<TransactionResult>;
    getTransaction(id: string): Promise<any>;
    ensureConnected(): Promise<any>;
    waitUntilImmutable(txId: string): Promise<any>;
}

export class RouletteController extends RoundBasedGameController<RouletteBetType> {
    static readonly MAX_BET_NUM: number;
    readonly contract: RouletteContract;
    game: RouletteGame;
    betType: RouletteBetType;
    constructor(eos: EOS);
    betToString(result: RouletteBetType): string;
    getResultString(): string;
}

export class TokenSymbol {
    readonly symbol: string;
    readonly precision: number;
    static fromString(str: string): TokenSymbol;
    constructor(symbol: string, precision: number);
}
export class Token {
    readonly symbol: string;
    readonly contract: string;
    readonly precision: number;
    static readonly EOS: Token;
    static readonly NONE: Token;
    static readonly ALL_TOKENS: Token[];
    static initialize(): void;
    static fromSymbol(symbol: string): Token;
    static fromContract(contract: string): Token;
    readonly baseUnit: number;
    constructor(symbol: string, contract: string, precision: number);
    toString(): string;
}

export enum NetworkType {
    MAINNET = 0,
    LOCALHOST = 1,
    KYLIN = 2
}
export class Network {
    readonly type: NetworkType;
    readonly host: string;
    readonly port: number;
    readonly network: 'testnet' | 'mainnet';
    readonly protocol: 'http' | 'https';
    readonly chainId: string;
    readonly blockchain: string;
    static readonly MAINNET: Network;
    static readonly LOCALHOST: Network;
    static readonly KYLIN: Network;
    constructor(type: NetworkType, host: string, port: number, network: 'testnet' | 'mainnet', protocol: 'http' | 'https', chainId: string, blockchain?: string);
}

export class Asset {
    readonly quantity: number;
    readonly token: Token;
    static DEFAULT: Asset;
    static fromRawAmount(amount: number, token: Token): Asset;
    static fromString(str: string): Asset;
    static findBySymbol(assets: Asset[], symbol: string): Asset;
    constructor(quantity: number, token: Token);
    toString(): string;
    add(value: number): Asset;
    baseQuatity(): number;
    plus(asset: Asset): Asset;
    minus(value: number): Asset;
}

export enum RouletteBetType {
    Unknown = 0,
    Bet0 = 1,
    Bet1 = 2,
    Bet2 = 3,
    Bet3 = 4,
    Bet4 = 5,
    Bet5 = 6,
    Bet6 = 7,
    Bet7 = 8,
    Bet8 = 9,
    Bet9 = 10,
    Bet10 = 11,
    Bet11 = 12,
    Bet12 = 13,
    Bet13 = 14,
    Bet14 = 15,
    Bet15 = 16,
    Bet16 = 17,
    Bet17 = 18,
    Bet18 = 19,
    Bet19 = 20,
    Bet20 = 21,
    Bet21 = 22,
    Bet22 = 23,
    Bet23 = 24,
    Bet24 = 25,
    Bet25 = 26,
    Bet26 = 27,
    Bet27 = 28,
    Bet28 = 29,
    Bet29 = 30,
    Bet30 = 31,
    Bet31 = 32,
    Bet32 = 33,
    Bet33 = 34,
    Bet34 = 35,
    Bet35 = 36,
    Bet36 = 37,
    BetEven = 38,
    BetOdd = 39,
    BetLarge = 40,
    BetSmall = 41,
    BetFront = 42,
    BetMid = 43,
    BetEnd = 44,
    BetLineOne = 45,
    BetLineTwo = 46,
    BetLineThree = 47,
    BetRed = 48,
    BetBlack = 49
}
export class RouletteGame extends RoundBasedGame {
    readonly result: number;
    constructor(value: any);
}
export class RouletteGameTable extends Table<RouletteGame> {
    constructor(eos: EOS, contract: string);
    protected convert(row: any[]): RouletteGame[];
}

export class ScratchController extends SinglePlayerGameController<ScratchGame> {
    readonly contract: ScratchContract;
    history: ScratchHistoryRow[];
    cards: ScratchCardsRow;
    protected readonly gameTable: Table<ScratchGame>;
    constructor(eos: EOS, store?: Store);
    makeBet(amount: number): Promise<TransactionResult>;
    buyCards(cardType: ScratchCardType, price: number, count: number): Promise<TransactionResult>;
    openCard(cardType: ScratchCardType): Promise<TransactionResult>;
    canClaim(): boolean;
    claim(): Promise<TransactionResult>;
    betText(): string;
    refreshCardsCount(): Promise<any>;
    protected canFinishLoading(): boolean;
    protected createEmptyGame(): ScratchGame;
    protected getHistory(): void;
}

export enum ScratchCardType {
    Pig = 0
}
export class ScratchContract extends GameContract {
    readonly gameTable: ScratchGameTable;
    readonly historyTable: ScratchHistoryTable;
    readonly cardsTable: ScratchCardsTable;
    constructor(house: HouseContract);
    init(): Promise<TransactionResult>;
    setGlobal(key: number, value: number): Promise<TransactionResult>;
    play(cardType: ScratchCardType, price: number, count: number, asset: Asset, referer: string): Promise<TransactionResult>;
    openCard(cardType: ScratchCardType, referer: string): Promise<TransactionResult>;
    claim(): Promise<TransactionResult>;
}

export enum ScratchStatus {
    Unknown = 0,
    Pending = 1,
    Revealed = 2
}
export enum ScratchResult {
    Hit = 1,
    Bonus = 2,
    Miss = 3
}
export class ScratchLine {
    readonly reward: number;
    readonly result: ScratchResult;
    readonly value: number;
    readonly values: number[];
    constructor(reward: number, result: ScratchResult, value: number, values: number[]);
}
export class ScratchGame extends SinglePlayerGame {
    readonly price: Asset;
    readonly reward: Asset;
    readonly result: number;
    readonly cardType: ScratchCardType;
    readonly status: ScratchStatus;
    constructor(value: any);
    getResults(): ScratchLine[];
    isActive(): boolean;
    canMakeBet(): boolean;
}

export interface EOSConnector {
    network: Network;
    eos: any;
    hasPlugin?: boolean;
    initialized: boolean;
    loggedIn: boolean;
    login(): Promise<any>;
    logout(): Promise<any>;
    getAccount(): Account;
}

export class Account {
    readonly name: string;
    readonly authority: string;
    static readonly DEFAULT: Account;
    readonly blockchain: string;
    constructor(name: string, authority: string);
    isValid(): boolean;
    toString(): string;
}

export class Table<T> {
    readonly name: string;
    readonly key: string;
    readonly code: string;
    readonly scope: string;
    constructor(eos: EOS, name: string, key: string, code: string, scope?: string);
    readAll(): Promise<T[]>;
    read(lower: string, limit: number): Promise<T[]>;
    getById(id: string): Promise<T | undefined>;
    protected convert(row: any[]): T[];
}

export enum TransactionError {
    None = 0,
    Unknown = 1,
    Locked = 2,
    UserRejected = 3,
    Invalid = 4,
    Failure = 5,
    Resource = 6
}
export class TransactionResult {
    readonly id: string;
    readonly blockNumber: number;
    readonly executed: boolean;
    readonly errorType: TransactionError;
    static fromReceipt(result: any): TransactionResult;
    static fromError(error: any): TransactionResult;
    constructor(id: string, blockNumber: number, executed: boolean, errorType: TransactionError);
    readonly isError: boolean;
}

export interface Limit {
    readonly used: number;
    readonly available: number;
    readonly max: number;
}
export class AccountInfo {
    readonly account: Account;
    info: any;
    static DEFAULT: AccountInfo;
    readonly balance: Asset;
    readonly cpuLimit: Limit;
    readonly netLimit: Limit;
    readonly ramLimit: Limit;
    constructor(account: Account, info: any);
}

export abstract class RoundBasedGameController<T> extends GameController {
    gameTicker: any;
    referer: string;
    playerNum: any;
    abstract game: RoundBasedGame;
    abstract readonly contract: RoundBasedGameContract<T>;
    bets: Array<Bet<T>>;
    betsSorted: Array<Bet<T>>;
    history: Array<BetHistory<T>>;
    bet: any;
    otherBets: any;
    betType: T;
    message: string;
    restTime: number;
    hasNewBet: boolean;
    hasNewOtherBet: boolean;
    result: any;
    lastBets: any[];
    firstActive: boolean;
    initialize(referer?: string): Promise<any>;
    destroy(): void;
    loadGame(): Promise<any>;
    loadHistory(): Promise<any>;
    setBetType(betType: T): void;
    startGetGame(delay?: number, txId?: string, callback?: () => any): Promise<any>;
    startTick(): void;
    update(): void;
    stopTick(): void;
    stopGameTicker(): void;
    getBets(): void;
    checkUpdate(): any[];
    checkOtherData(data: any[]): any[];
    addArray(orgin: any[], nowData: any): boolean;
    updateBets(): void;
    status(): RoundStatus;
    roundActive(): boolean;
    betText(): string;
    canMakeBet(): boolean;
    makeBet(amount: number): Promise<TransactionResult>;
    makeBets(bets: {
        [key: number]: Asset;
    }): Promise<TransactionResult>;
    abstract betToString(result: T): string;
    abstract getResultString(): string;
}

export class RouletteContract extends RoundBasedGameContract<RouletteBetType> {
    static readonly ID: number;
    static contract(network: NetworkType): string;
    readonly gameTable: RouletteGameTable;
    readonly resultTable: Table<GameResult<RouletteBetType>>;
    constructor(house: HouseContract, converter: (_: RouletteBetType) => string);
}

export enum RoundStatus {
    Unknown = 0,
    StandBy = 1,
    Active = 2
}
export abstract class RoundBasedGame {
    readonly id: number;
    readonly endTime: number;
    readonly status: RoundStatus;
    readonly symbol: string;
    readonly largestWinner: string;
    readonly largestWinAmount: Asset;
    protected constructor(value: any);
    canStartBet(): boolean;
    isActive(): boolean;
}

export enum LoadingStatus {
    Initializing = 0,
    NotLoading = 1,
    Loading = 2
}
export abstract class SinglePlayerGameController<T extends SinglePlayerGame> extends GameController {
    historyTicker: any;
    gameTicker: any;
    lastGame: T;
    game: T;
    lastId: number;
    referer: string;
    loadingStatus: LoadingStatus;
    abstract readonly contract: GameContract;
    protected abstract readonly gameTable: Table<T>;
    protected constructor(eos: EOS, store: Store);
    initialize(referer: string): Promise<any>;
    destroy(): void;
    reset(): void;
    startGetMyGame(delay?: number, txId?: string): Promise<any>;
    stopGetMyGame(): void;
    startGetHistory(): void;
    canMakeBet(): boolean;
    onBetMade(txId: string): void;
    protected abstract canFinishLoading(): boolean;
    protected abstract createEmptyGame(): T;
    protected abstract getHistory(): void;
}

export interface Store {
    state: any;
    commit(action: string, data: any): void;
}
export class LocalStorate {
    locale: Locale;
    bgm: BGM;
    sound: Sound;
    guide: Guide;
    constructor(store: Store);
    setLocal(locale: Locale): void;
    setBGM(bgm: BGM): void;
    setSound(sound: Sound): void;
    setGuide(guide: Guide): void;
}

export class ScratchHistoryRow {
    id: number;
    cardId: number;
    player: string;
    price: Asset;
    reward: Asset;
    result: number;
    cardType: ScratchCardType;
    seed: string;
    timestamp: Timestamp;
    constructor(value: any);
}
export class ScratchHistoryTable extends Table<ScratchHistoryRow> {
    constructor(eos: EOS, contract: string);
    protected convert(row: any[]): ScratchHistoryRow[];
}

export class ScratchCardsRow {
    readonly player: string;
    readonly card1Count: any;
    readonly card2Count: any;
    constructor(value: any);
}
export class ScratchCardsTable extends Table<ScratchCardsRow> {
    constructor(eos: EOS, contract: string);
    protected convert(row: any[]): ScratchCardsRow[];
}

export class HouseContract extends Contract {
    constructor(eos: EOS);
    makeTokenTable(name: string): TokenTable;
    makePlayerTable(name: string): PlayerTable;
    addGame(game: string, id: number): Promise<TransactionResult>;
    setActive(game: string, active: boolean): Promise<TransactionResult>;
    updateToken(game: string, token: Token, min: number, max: number, balance: number): Promise<TransactionResult>;
}

export enum GAME_IDS {
    Dice = 1,
    Blackjack = 2,
    Baccarat = 3,
    RedBlack = 4,
    Roulette = 5,
    ClassicBaccarat = 6,
    Scratch = 7
}
export abstract class GameContract extends Contract {
    protected readonly house: HouseContract;
    readonly id: number;
    readonly tokens: TokenTable;
    readonly globals: GlobalTable;
    readonly players: PlayerTable;
    constructor(name: string, house: HouseContract, id: number);
    setActive(active: boolean): Promise<TransactionResult>;
}

export class ScratchGameTable extends Table<ScratchGame> {
    constructor(eos: EOS, contract: string);
    protected convert(row: any[]): ScratchGame[];
}

export abstract class SinglePlayerGame {
    readonly id: number;
    readonly player: string;
    readonly referer: string;
    readonly seed: string;
    readonly timestamp: Timestamp;
    protected constructor(value: any);
    abstract canMakeBet(): boolean;
}

export abstract class GameController implements BetCallback {
    readonly eos: EOS;
    readonly localStorage: LocalStorate;
    readonly house: HouseContract;
    readonly accountControl: AccountInfoControl;
    readonly betControl: BetController;
    abstract contract: GameContract;
    protected constructor(eos: EOS, store: Store);
    abstract initialize(ref: string): any;
    abstract destroy(): void;
    loggedIn(): boolean;
    login(): Promise<any>;
    logout(): void;
    referralLink(baseUrl: string): string;
    readonly isCN: boolean;
    setLocale(locale: Locale): void;
    toggleLocale(): void;
    setBGM(bgm: BGM): void;
    readonly isBgmOn: boolean;
    toggleBGM(): void;
    setSound(sound: Sound): void;
    readonly isSoundOn: boolean;
    toggleSound(): void;
    readonly isGuideEd: boolean;
    setGuide(guide: Guide): void;
    setGuideEd(): void;
    abstract betText(): string;
    abstract canMakeBet(): boolean;
    abstract makeBet(amount: number): Promise<TransactionResult>;
    makeBets(bets: {
        [key: number]: Asset;
    }): Promise<TransactionResult>;
}

export abstract class RoundBasedGameContract<T> extends GameContract {
    readonly globalVarTable: GlobalTable;
    readonly betTable: Table<Bet<T>>;
    readonly historyTable: Table<BetHistory<T>>;
    abstract readonly gameTable: Table<RoundBasedGame>;
    abstract readonly resultTable: Table<GameResult<T>>;
    protected constructor(name: string, house: HouseContract, id: number, converter: (_: T) => string);
    init(): Promise<TransactionResult>;
    setGlobal(key: number, value: number): Promise<TransactionResult>;
    close(id: number): Promise<TransactionResult>;
    reveal(id: number): Promise<TransactionResult>;
    play(gameId: number, bets: {
        [key: number]: Asset;
    }, referer: string): Promise<TransactionResult>;
}

export class Bet<T> {
    readonly id: number;
    readonly gameId: number;
    readonly player: string;
    readonly referer: string;
    readonly bet: Asset;
    readonly betType: T;
    readonly betString: string;
    constructor(value: any, converter: (_: T) => string);
}
export class BetTable<T> extends Table<Bet<T>> {
    constructor(eos: EOS, contract: string, converter: (_: T) => string);
    protected convert(row: any[]): Array<Bet<T>>;
}

export class BetHistory<T> {
    readonly id: number;
    readonly gameId: number;
    readonly player: string;
    readonly bet: Asset;
    readonly payout: Asset;
    readonly betType: T;
    readonly betString: string;
    readonly time: number;
    constructor(value: any, converter: (_: T) => string);
}
export class BetHistoryTable<T> extends Table<BetHistory<T>> {
    constructor(eos: EOS, contract: string, converter: (_: T) => string);
    protected convert(row: any[]): Array<BetHistory<T>>;
}

export class GameResult<T> {
    readonly id: number;
    readonly gameId: number;
    readonly result: T[];
    constructor(value: any, bitmask: boolean);
}
export class GameResultTable<T> extends Table<GameResult<T>> {
    readonly bitmask: boolean;
    constructor(eos: EOS, contract: string, bitmask?: boolean);
    protected convert(row: any[]): Array<GameResult<T>>;
}

export enum Locale {
    EN = 0,
    CN = 1
}
export enum BGM {
    BGM_ON = 0,
    BGM_OFF = 1
}
export enum Sound {
    Sound_ON = 0,
    Sound_OFF = 1
}
export enum Guide {
    Guide_ED = 0,
    Guide_UN = 1
}

export class Dates {
    static initialize(): void;
    static toISOTimestamp(str: string): number;
}
export class Timestamp {
    readonly value: number;
    constructor(str: string);
    toString(): string;
}

export interface TokenRow {
    sym: string;
    contract: string;
    in: number;
    out: number;
    play_times: number;
    min: number;
    max: number;
    balance: number;
}
export class TokenTable extends Table<TokenRow> {
    constructor(eos: EOS, contract: string, scope?: string);
    protected convert(row: any[]): TokenRow[];
}

export class PlayerRow {
    readonly name: string;
    readonly in: Asset;
    readonly out: Asset;
    readonly playTimes: number;
    readonly lastPlayTime: number;
    readonly eventIn: Asset;
    constructor(value: any);
    toString(): string;
}
export class PlayerTable extends Table<PlayerRow> {
    constructor(eos: EOS, contract: string, scope: string);
    protected convert(row: any[]): PlayerRow[];
}

export class Contract {
    readonly name: string;
    readonly eos: EOS;
    constructor(name: string, eos: EOS);
    accountName(): string;
    pushAction(name: string, data: any): Promise<TransactionResult>;
    transfer(asset: Asset, memo?: string): Promise<TransactionResult>;
}

export interface GlobalVarTableRow {
    id: number;
    val: number;
}
export class GlobalTable extends Table<GlobalVarTableRow> {
    constructor(eos: EOS, contract: string);
    protected convert(rows: any[]): GlobalVarTableRow[];
}

export interface BalanceEffectCallback {
    startBalanceEffect(amount: number, duration?: number): void;
}
export interface BetCallback {
    betText(): string;
    canMakeBet(): boolean;
    makeBet(amount: number): Promise<TransactionResult>;
    makeBets(bets: {
        [key: number]: Asset;
    }): Promise<TransactionResult>;
}
export class BetController {
    readonly accountInfoControl: AccountInfoControl;
    static readonly MIN_BET: number;
    static readonly MAX_BET: number;
    amount: number;
    effectCallback?: BalanceEffectCallback;
    isBetting: boolean;
    betSuc: boolean;
    betFail: boolean;
    tipsTxt: string;
    tipsTxtEn: string;
    constructor(eos: EOS, betCallback: BetCallback, accountInfoControl: AccountInfoControl);
    setEffectCallback(effectCallback: BalanceEffectCallback): void;
    makeBet(): Promise<any>;
    getFailureMessage(e: TransactionError): string;
    finishBet(profit: number): Promise<any>;
    getBalance(): Asset;
    getBetAsset(): Asset;
    canMakeBet(): boolean;
    betText(): string;
    stepAmount(times: number): void;
    setAmount(amount: number): void;
    setMin(): void;
    setMax(): void;
}

export class AccountInfoControl {
    static getInstance(eos: EOS): AccountInfoControl;
    accountInfo: AccountInfo;
    ensureUpToDate(): Promise<any>;
    adjustBalance(amount: number): void;
    startUpdate(): Promise<any>;
    stopUpdate(): void;
    destroy(): void;
}
}
